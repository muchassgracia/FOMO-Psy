<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.487">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>FOMO-Psy: Formal Modeling of Psychological Theories - Session X - How to write the final report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">FOMO-Psy: Formal Modeling of Psychological Theories</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../sessions/sessions_overview.html"> 
<span class="menu-text">Sessions</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lectures/lecture_overview.html"> 
<span class="menu-text">Lectures</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../skills/skills_overview.html"> 
<span class="menu-text">Skills</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../tools.html"> 
<span class="menu-text">Thinking Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../orga_material/orga_material.html"> 
<span class="menu-text">Organizational Material</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#final-report" id="toc-final-report" class="nav-link active" data-scroll-target="#final-report"><span class="header-section-number">1</span> Final report</a>
  <ul class="collapse">
  <li><a href="#step-0.-identify-the-focal-constructs-of-your-theory" id="toc-step-0.-identify-the-focal-constructs-of-your-theory" class="nav-link" data-scroll-target="#step-0.-identify-the-focal-constructs-of-your-theory"><span class="header-section-number">1.1</span> Step 0. Identify the focal constructs of your theory</a></li>
  <li><a href="#step-1.-identify-relevant-phenomena" id="toc-step-1.-identify-relevant-phenomena" class="nav-link" data-scroll-target="#step-1.-identify-relevant-phenomena"><span class="header-section-number">1.2</span> Step 1. Identify relevant phenomena</a></li>
  <li><a href="#step-2.-formulate-a-prototheory-sketch-the-existing-verbal-theory" id="toc-step-2.-formulate-a-prototheory-sketch-the-existing-verbal-theory" class="nav-link" data-scroll-target="#step-2.-formulate-a-prototheory-sketch-the-existing-verbal-theory"><span class="header-section-number">1.3</span> Step 2. Formulate a prototheory / Sketch the existing verbal theory</a></li>
  <li><a href="#step-3.-develop-a-formal-model" id="toc-step-3.-develop-a-formal-model" class="nav-link" data-scroll-target="#step-3.-develop-a-formal-model"><span class="header-section-number">1.4</span> Step 3. Develop a formal model:</a></li>
  <li><a href="#step-4.-check-the-adequacy-of-the-formal-model" id="toc-step-4.-check-the-adequacy-of-the-formal-model" class="nav-link" data-scroll-target="#step-4.-check-the-adequacy-of-the-formal-model"><span class="header-section-number">1.5</span> Step 4. Check the adequacy of the formal model</a></li>
  <li><a href="#step-5.-evaluate-the-overall-worth-of-the-constructed-theory" id="toc-step-5.-evaluate-the-overall-worth-of-the-constructed-theory" class="nav-link" data-scroll-target="#step-5.-evaluate-the-overall-worth-of-the-constructed-theory"><span class="header-section-number">1.6</span> Step 5. Evaluate the overall worth of the constructed theory</a></li>
  </ul></li>
  <li><a href="#formal-stuff" id="toc-formal-stuff" class="nav-link" data-scroll-target="#formal-stuff"><span class="header-section-number">2</span> Formal stuff</a>
  <ul class="collapse">
  <li><a href="#hausarbeit" id="toc-hausarbeit" class="nav-link" data-scroll-target="#hausarbeit"><span class="header-section-number">2.1</span> Hausarbeit</a></li>
  <li><a href="#abgabe-hausarbeit" id="toc-abgabe-hausarbeit" class="nav-link" data-scroll-target="#abgabe-hausarbeit"><span class="header-section-number">2.2</span> Abgabe Hausarbeit</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Session X - How to write the final report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="final-report" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Final report</h1>
<p>Your task is to formalize a psychological theory of your choice. The goal is <em>not</em> to do a complete formalization, but to demonstrate that you understand the methodological steps of the TCM (steps 1-4, as we practiced them in the course) and that you are able to apply them to a new theory.</p>
<p>Hence, it is sufficient in each step to make an exemplary demonstration of the necessary steps, without the goal of being exhaustive. Also, whether the final formalization makes sense or the formal model really produces the phenomenon is not part of the grading (because that also depends on the chosen theory). For grading, I only assess whether the methodological steps have been applied <em>lege artis</em> and a coherent report has been written (e.g.: do the steps meaningfully build upon each other? Do the conclusions follow from the presented evidence?).</p>
<section id="step-0.-identify-the-focal-constructs-of-your-theory" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="step-0.-identify-the-focal-constructs-of-your-theory"><span class="header-section-number">1.1</span> Step 0. Identify the focal constructs of your theory</h2>
<ul>
<li>if the theory is large, or there are several versions: Limit yourself to the main theoretical relationships and constructs.</li>
</ul>
</section>
<section id="step-1.-identify-relevant-phenomena" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="step-1.-identify-relevant-phenomena"><span class="header-section-number">1.2</span> Step 1. Identify relevant phenomena</h2>
<p><em>(for details, see <a href="../sessions/S8-TCM_Step1.html">Session 8</a>)</em>.</p>
<ul>
<li>Search for at least 1 meta-analysis of your focal constructs</li>
<li>Only if no meta-analysis available, or not helpful: Search for 2-3 exemplary primary studies. You do <em>not</em> have to conduct a full-blown meta-analysis.</li>
<li>Based on this (limited, not exhaustive) literature: Assess the robustness of the phenomena. Give a clear answer “The phenomenon can (not) be considered robust because, …” by referring to the two dimensions of robustness:
<ul>
<li>Strength of evidence</li>
<li>Generalizability (cf.&nbsp;UTOS framework)</li>
</ul></li>
</ul>
<p>Note: If the phenomena turn out to be not robust, there is no need to change your chosen theory. Just work with what you have.</p>
</section>
<section id="step-2.-formulate-a-prototheory-sketch-the-existing-verbal-theory" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="step-2.-formulate-a-prototheory-sketch-the-existing-verbal-theory"><span class="header-section-number">1.3</span> Step 2. Formulate a prototheory / Sketch the existing verbal theory</h2>
<p><em>(for details, see <a href="../sessions/S9-TCM_Step2.html">Session 9</a>)</em>.</p>
<ul>
<li>Search the literature for key theoretical statements; put them into a table and assign IDs to each atomic statement</li>
<li>Create a VAST display</li>
</ul>
</section>
<section id="step-3.-develop-a-formal-model" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="step-3.-develop-a-formal-model"><span class="header-section-number">1.4</span> Step 3. Develop a formal model:</h2>
<p><em>(for details, see <a href="../sessions/S10-TCM_Step3.html">Session 10</a>)</em>.</p>
<ul>
<li>Define the mathematical properties of the variables in your formal model (scale level, range, semantic anchors)</li>
<li>Define functional relationships between variables</li>
<li>Implement the functions in R</li>
<li>Simulate a full data set with virtual participants</li>
</ul>
</section>
<section id="step-4.-check-the-adequacy-of-the-formal-model" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="step-4.-check-the-adequacy-of-the-formal-model"><span class="header-section-number">1.5</span> Step 4. Check the adequacy of the formal model</h2>
<p><em>(for details, see <a href="../sessions/S11-TCM_Step4.html">Session 11</a>)</em>.</p>
<ul>
<li>Test boundary conditions and do a sensitivity analysis</li>
<li>In the the final report, no full-blown sensitivity analysis is necessary - just the bivariate plots of the functional relationships</li>
</ul>
</section>
<section id="step-5.-evaluate-the-overall-worth-of-the-constructed-theory" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="step-5.-evaluate-the-overall-worth-of-the-constructed-theory"><span class="header-section-number">1.6</span> Step 5. Evaluate the overall worth of the constructed theory</h2>
<p>(not covered in this course).</p>
</section>
</section>
<section id="formal-stuff" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Formal stuff</h1>
<ul>
<li>15,000 characters is not much: Keep every step short, crisp and spot-on.</li>
<li>You need to hand in a PDF, which is accompanied by a project on a repository (e.g., Github)</li>
<li>Code, supplemental material, etc. goes into the repository and will be part of the grading.</li>
</ul>
<section id="hausarbeit" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="hausarbeit"><span class="header-section-number">2.1</span> Hausarbeit</h2>
<ul>
<li>Schriftgröße 12pt, Zeilenabstand 1.5x</li>
<li>15.000 Zeichen +/- 20% (Zählung inkl. Leerzeichen; ohne Deckblatt, Referenzen und Anhänge)</li>
<li>Wenn Sie in papaja/Rmarkdown schreiben, dann ist das exportierte PDF von der Formatierung her gut so wie es ist (Sie brauchen nicht das Deckblatt, Zeilenabstand etc. anpassen).</li>
<li>Deckblatt: Titel, Datum, Name, Matrikel-Nr., Name der Veranstaltung</li>
<li>Bei papaja/Rmarkdown schreiben Sie Datum, Matrikel-Nr. und Name der Veranstaltung in die author notes.</li>
<li>Kein Inhaltsverzeichnis</li>
<li>Mindestens 3 Publikationen zitieren</li>
<li>Zitate &amp; Literaturverzeichnis nach <a href="http://owl.english.purdue.edu/owl/resource/664/01/">APA-Richtlinien</a> (6. oder 7. Version)</li>
<li>Die Links zu Repositorium mit open code, etc. kommen an den Anfang des Methodenteils</li>
</ul>
</section>
<section id="abgabe-hausarbeit" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="abgabe-hausarbeit"><span class="header-section-number">2.2</span> Abgabe Hausarbeit</h2>
<ul>
<li>Als PDF-Datei per Email an den Dozenten – Empfang wird bestätigt</li>
<li>Abgabetermin: 19.3.2024</li>
<li>Man kann zum Zwecke der Anonymisierung 2 Versionen einreichen:
<ul>
<li>Vollständige Version (Dateiname: IhrNachname_Kurztitel_Jahr.pdf) – z.B.: „Schmid_Empra_2020.pdf“</li>
<li>Anonymisierte Version, bei welcher der Name auf dem Deckblatt gelöscht ist (Dateiname: Matrikelnummer_Kurztitel_Jahr.pdf)
<ul>
<li>Diese Version wird benotet.</li>
<li>Dateiname z.B.:„98234034_Empra_2020.pdf“</li>
<li>Das Github Repo als zip-Datei.</li>
<li>Sie können in papaja einfach eine anonyme Version erzeugen,indem Sie im YAML <code>mask: yes</code> angeben (siehe <a href="https://frederikaust.com/papaja_man/r-markdown-components.html">hier</a>)</li>
</ul></li>
</ul></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>